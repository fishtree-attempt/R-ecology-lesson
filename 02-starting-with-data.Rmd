---
title: Starting with data
author: Data Carpentry contributors
minutes: 20
---

```{r, echo=FALSE, purl=FALSE, message = FALSE}
source("setup.R")
```

------------

> ## Learning Objectives
>
> * Describe what a data.frame is.
> * Summarize the contents of a dataframe in R.
> * Load external data from a .csv file into R.
> * Manipulate categorical data in R.

------------

## Presentation of the Survey Data

```{r, echo=FALSE, purl=TRUE}
### Presentation of the survey data
```

We are studying the species and weight of animals caught in plots in our study
area. The dataset is stored as a comma separated value (CSV) file.
Each row holds information for a single animal, and the columns represent:

| Column           | Description                        |
|------------------|------------------------------------|
| record\_id       | Unique id for the observation      |
| month            | month of observation               |
| day              | day of observation                 |
| year             | year of observation                |
| plot\_id         | ID of a particular plot            |
| species\_id      | 2-letter code                      |
| sex              | sex of animal ("M", "F")           |
| hindfoot\_length | length of the hindfoot in mm       |
| weight           | weight of the animal in grams      |
| genus            | genus of animal                    |
| species          | species of animal                  |
| taxa             | e.g. Rodent, Reptile, Bird, Rabbit |
| plot\_type       | type of plot                       |

We are going to use the R function `download.file()` to download the CSV file
that contains the survey data from figshare, and we will use `read.csv()` to
load into memory the content of the CSV file as a `data.frame`.

To download the data into the `data/` subdirectory, do:

```{r, eval=FALSE, purl=TRUE}
download.file("https://ndownloader.figshare.com/files/2292169",
              "data/portal_data_joined.csv")
```

You are now ready to load the data:

```{r, eval=TRUE,  purl=FALSE}
surveys <- read.csv('data/portal_data_joined.csv')
```

This statement doesn't produce any output because, as you might recall,
assignment doesn't display anything. If we want to check that our data has been
loaded, we can print the variable's value: `surveys`.

Wow... that was a lot of output. At least it means the data loaded
properly. Let's check the top (the first 6 lines) of this `data.frame` using the
function `head()`:

```{r, results='show', purl=FALSE}
head(surveys)
```

A `data.frame` is the representation of data in the format of a table where the
columns are vectors that all have the same length. Because the column are
vectors, they all contain the same type of data. We can see this when inspecting
the __str__ucture of a `data.frame` with the function `str()`:

```{r, purl=FALSE}
str(surveys)
```

### Challenge

Based on the output of `str(surveys)`, can you answer the following questions?

* What is the class of the object `surveys`?
* How many rows and how many columns are in this object?
* How many species have been recorded during these surveys?

```{r, echo=FALSE, purl=TRUE}

## Challenge
## Based on the output of `str(surveys)`, can you answer the following questions?
## * What is the class of the object `surveys`?
## * How many rows and how many columns are in this object?
## * How many species have been recorded during these surveys?

```

<!---
```{r, echo=FALSE, purl=FALSE}
## Answers
##
## * class: data frame
## * how many rows: 34786,  how many columns: 13
## * how many species: 48
```
--->

As you can see, many of the columns consist of integers, however, the columns
`species` and `sex` are of a special class called a `factor`. Before we learn
more about the `data.frame` class, let's talk about factors. They are very
useful but not necessarily intuitive, and therefore require some attention.

## Inspecting `data.frame` Objects

We already saw how the functions `head()` and `str()` can be useful to check the
content and the structure of a `data.frame`. Here is a non-exhaustive list of
functions to get a sense of the content/structure of the data.

* Size:
    * `dim()` - returns a vector with the number of rows in the first element,
          and the number of columns as the second element (the **dim**ensions of
          the object)
    * `nrow()` - returns the number of rows
    * `ncol()` - returns the number of columns

* Content:
    * `head()` - shows the first 6 rows
    * `tail()` - shows the last 6 rows

* Names:
    * `names()` - returns the column names (synonym of `colnames()` for `data.frame`
	   objects)
    * `rownames()` - returns the row names

* Summary:
    * `str()` - structure of the object and information about the class, length and
	   content of  each column
    * `summary()` - summary statistics for each column

Note: most of these functions are "generic", they can be used on other types of
objects besides `data.frame`.

## Indexing, Sequences, and Subsetting

```{r, echo=FALSE, purl=TRUE}

## Sequences and Subsetting data frames
```

`:` is a special function that creates numeric vectors of integers in increasing
or decreasing order, test `1:10` and `10:1` for instance. The function `seq()`
(for **seq**uence) can be used to create more complex patterns:

```{r, results='show', purl=FALSE}
seq(1, 10, by=2)
seq(5, 10, length.out=3)
seq(50, by=5, length.out=10)
seq(1, 8, by=3) # sequence stops to stay below upper limit
```

Our survey data frame has rows and columns (it has 2 dimensions), if we want to
extract some specific data from it, we need to specify the "coordinates" we
want from it. Row numbers come first, followed by column numbers. However, note
that different ways of specifying these coordinates lead to results with
different classes.

```{r, purl=FALSE}
surveys[1]      # first column in the data frame (as a data.frame)
surveys[,1]     # first column in the data frame (as a vector)
surveys[1, 1]   # first element in the first column of the data frame (as a vector)
surveys[1, 6]   # first element in the 6th column (as a vector)
surveys[1:3, 7] # first three elements in the 7th column (as a vector)
surveys[3, ]    # the 3rd element for all columns (as a data.frame)
head_surveys <- surveys[1:6, ] # equivalent to head(surveys)
```

You can also exclude certain parts of a data frame
```{r, purl=FALSE}
surveys[,-1]   #The whole data frame, except the first column
surveys[-c(7:34786),] #equivalent to head(surveys)
```

As well as using numeric values to subset a `data.frame` (or `matrix`), columns
can be called by name, using one of the three following notations:

```{r, eval = FALSE, purl=FALSE}
surveys["species_id"]       # Result is a data.frame
surveys[, "species_id"]     # Result is a vector
surveys[["species_id"]]     # Result is a vector
surveys$species_id          # Result is a vector
```

For our purposes, these three notations are equivalent. However, the last one
with the `$` does partial matching on the name. So you could also select the
column `"day"` by typing `surveys$d`. It's a shortcut, as with all shortcuts,
they can have dangerous consequences, and are best avoided. Besides, with
auto-completion in RStudio, you rarely have to type more than a few characters
to get the full and correct column name.

### Challenge

1. The function `nrow()` on a `data.frame` returns the number of rows. Use it,
   in conjunction with `seq()` to create a new `data.frame` called
   `surveys_by_10` that includes every 10th row of the survey data frame
   starting at row 10 (10, 20, 30, ...)

2. Create a `data.frame` containing only the observations from row 1999 of the
   `surveys` dataset.

3. Notice how `nrow()` gave you the number of rows in a `data.frame`? Use `nrow()`
  instead of a row number to make a `data.frame` with observations from only the last
  row of the `surveys` dataset.

4. Now that you've seen how `nrow()` can be used to stand in for a row index, let's combine
  that behavior with the `-` notation above to reproduce the behavior of `head(surveys)`
  excluding the 7th through final row of the `surveys` dataset.

```{r, echo=FALSE, purl=TRUE}
### Challenges:
### 1. The function `nrow()` on a `data.frame` returns the number of
### rows. Use it, in conjuction with `seq()` to create a new
### `data.frame` called `surveys_by_10` that includes every 10th row
### of the survey data frame starting at row 10 (10, 20, 30, ...)
###
### 2. Create a data.frame containing only the observation from row 1999 of the -->
### surveys dataset.
###
### 3. Notice how `nrow()` gave you the number of rows in a `data.frame`? Use `nrow()`
###   instead of a row number to make a `data.frame` with observations from only the last
###   row of the `surveys` dataset.
###
### 4. Now that you've seen how `nrow()` can be used to stand in for a row index, let's combine
###   that behavior with the `-` notation above to reproduce the behavior of `head(surveys)`
###   excluding the 7th through final row of the `surveys` dataset.
```

<!---
```{r, purl=FALSE}
## Answers
surveys_by_10 <- surveys[seq(10, nrow(surveys), by=10), ]
surveys_1999 <- surveys[surveys$year == 1999, ]
surveys_last <- surveys[nrow(surveys),]
surveys_head <- surveys[-c(7:nrow(surveys)),]
```
--->


## Factors

```{r, echo=FALSE, purl=TRUE}
### Factors
```

Factors are used to represent categorical data. Factors can be ordered or
unordered, and understanding them is necessary for statistical analysis and for
plotting.

Factors are stored as integers, and have labels associated with these unique
integers. While factors look (and often behave) like character vectors, they are
actually integers under the hood, and you need to be careful when treating them
like strings.

Once created, factors can only contain a pre-defined set of values, known as
*levels*. By default, R always sorts *levels* in alphabetical order. For
instance, if you have a factor with 2 levels:

```{r, purl=TRUE}
sex <- factor(c("male", "female", "female", "male"))
```

R will assign `1` to the level `"female"` and `2` to the level `"male"` (because
`f` comes before `m`, even though the first element in this vector is
`"male"`). You can check this by using the function `levels()`, and check the
number of levels using `nlevels()`:

```{r, purl=FALSE}
levels(sex)
nlevels(sex)
```

Sometimes, the order of the factors does not matter, other times you might want
to specify the order because it is meaningful (e.g., "low", "medium", "high") or
it is required by a particular type of analysis. Additionally, specifying the
order of the levels allows for level comparison:

```{r, purl=TRUE, error=TRUE}
food <- factor(c("low", "high", "medium", "high", "low", "medium", "high"))
levels(food)
food <- factor(food, levels=c("low", "medium", "high"))
levels(food)
min(food) ## doesn't work
food <- factor(food, levels=c("low", "medium", "high"), ordered=TRUE)
levels(food)
min(food) ## works!
```

In R's memory, these factors are represented by integers (1, 2, 3), but are more
informative than integers because factors are self describing: `"low"`,
`"medium"`, `"high"`" is more descriptive than `1`, `2`, `3`. Which is low?  You
wouldn't be able to tell just from the integer data. Factors, on the other hand,
have this information built in. It is particularly helpful when there are many
levels (like the species in our example data set).

### Converting factors

If you need to convert a factor to a character vector, you use
`as.character(x)`.

Converting factors where the levels appear as numbers (such as concentration
levels, or years) to a numeric vector is a little trickier.  One method is to
convert factors to characters and then numbers.  Another method is to use the
`levels()` function. Compare:

```{r, purl=TRUE}
f <- factor(c(1990, 1983, 1977, 1998, 1990))
as.numeric(f)               ## wrong! and there is no warning...
as.numeric(as.character(f)) ## works...
as.numeric(levels(f))[f]    ## The recommended way.
```

Notice that in the `levels()` approach, three important steps occur:

* We obtain all the factor levels using `levels(f)`
* We convert these levels to numeric values using `as.numeric(levels(f))`
* We then access these numeric values using the underlying integers of the
  vector `f` inside the square brackets

### Challenge

The function `plot()` can be used to quickly create a bar plot of a factor. For instance, for the factor
`exprmt <- factor(c("treat1", "treat2", "treat1", "treat3", "treat1", "control", "treat1", "treat2", "treat3"))`, the code `plot(exprmt)`
gives you a barplot of the number of observations at each level, as shown
below.

* What determines the order in which the treatments are listed in the plot? (Hint: use `str` to inspect the factor.)
* How can you recreate this plot with "control" listed last instead
of first?


```{r wrong-order, results='show', echo=FALSE, purl=TRUE}
## The function `plot()` can be used to quickly create a bar plot of a factor.
## For instance, for a factor
exprmt <- factor(c("treat1", "treat2", "treat1", "treat3", "treat1",
		   "control", "treat1", "treat2", "treat3"))
## the code `plot(exprmt)`
## gives you a barplot of the number of observations, as shown below.

## * What determines the order in which the treatments are listed in the plot?
## * How can you recreate this plot with "control" listed last instead
## of first?
plot(exprmt)
```


<!---
```{r correct-order, purl=FALSE}
## Answers
##
## * The treatments are listed in alphabetical order because they are factors.
## * By redefining the order of the levels
exprmt <- factor(exprmt, levels=c("treat1", "treat2", "treat3", "control"))
plot(exprmt)
```
--->
